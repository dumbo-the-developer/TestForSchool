<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor and ZIP Downloader</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: auto; text-align: center; }
        .hidden { display: none; }
        input[type="file"] { margin: 10px 0; }
        button { margin: 10px; padding: 10px 20px; }
    </style>
</head>
<body>
<div class="container">
    <h2>Image Editor and ZIP Downloader</h2>
    <input type="file" id="image-upload" accept="image/jpeg" multiple>
    <button onclick="processImages()">Edit and Download as ZIP</button>
    <a id="download-link" class="hidden">Download Edited Images</a>
</div>

<canvas id="canvas" class="hidden"></canvas>

<!-- Include JSZip for creating ZIP files -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
    async function processImages() {
        const overlayImageUrl = 'cccc.png'; // Overlay image must be in the same directory
        const overlayImage = await loadImage(overlayImageUrl);
        const files = document.getElementById('image-upload').files;
        const zip = new JSZip();

        if (files.length === 0) {
            alert('Please upload at least one image.');
            return;
        }

        for (let file of files) {
            const img = await loadImage(URL.createObjectURL(file));
            const editedImage = editImage(img, overlayImage);
            const blob = await new Promise(resolve => editedImage.toBlob(resolve, 'image/jpeg'));
            zip.file(file.name, blob);
        }

        // Generate the ZIP file and provide download link
        zip.generateAsync({ type: 'blob' }).then(content => {
            const downloadLink = document.getElementById('download-link');
            downloadLink.href = URL.createObjectURL(content);
            downloadLink.download = 'edited-images.zip';
            downloadLink.textContent = 'Download Edited Images';
            downloadLink.classList.remove('hidden');
        });
    }

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
            img.src = src;
        });
    }

    function editImage(image, overlay) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        if (image.width === 325 && image.height === 520) {
            // New logic for image size 325px x 520px
            const overlayWidth = 100;
            const overlayHeight = 20;
            const newWidth = image.width - 35 - 35; // 35px crop from left and right
            const newHeight = image.height - 140 - 190; // 140px crop from top, 190px from bottom

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Draw the original image cropped for 325px x 520px size
            ctx.drawImage(image, 35, 140, newWidth, newHeight, 0, 0, newWidth, newHeight);

            // Draw the resized overlay on top of the cropped image at the specified position
            ctx.drawImage(overlay, 0, 0, overlay.width, overlay.height, 113 - 35, 308 - 140, overlayWidth, overlayHeight);
        } else {
            // Old logic for all other image sizes
            const left = 85;
            const upper = 285;
            const right = image.width - 85;
            const lower = image.height - 385;
            const newWidth = right - left;
            const newHeight = lower - upper;

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Draw the original image cropped for all other sizes
            ctx.drawImage(image, left, upper, newWidth, newHeight, 0, 0, newWidth, newHeight);

            // Draw the overlay on top of the cropped image at its original position (adjust if necessary)
            ctx.drawImage(overlay, 225 - 85, 616 - 285);
        }

        return canvas;
    }
</script>
</body>
</html>
