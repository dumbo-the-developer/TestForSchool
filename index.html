<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Editor and ZIP Downloader</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 600px; margin: auto; text-align: center; }
        .hidden { display: none; }
        input[type="file"] { margin: 10px 0; }
        button { margin: 10px; padding: 10px 20px; }
    </style>
</head>
<body>
<div class="container">
    <h2>Image Editor and ZIP Downloader</h2>
    <input type="file" id="image-upload" accept="image/jpeg" multiple>
    <button onclick="processImages()">Edit and Download as ZIP</button>
    <a id="download-link" class="hidden">Download Edited Images</a>
</div>

<canvas id="canvas" class="hidden"></canvas>

<!-- Include JSZip for creating ZIP files -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

<script>
    async function processImages() {
        const overlayImageUrl = 'cccc.png'; // Overlay image must be in the same directory
        const overlayImage = await loadImage(overlayImageUrl);
        const files = document.getElementById('image-upload').files;
        const zip = new JSZip();

        if (files.length === 0) {
            alert('Please upload at least one image.');
            return;
        }

        for (let file of files) {
            const img = await loadImage(URL.createObjectURL(file));
            const editedImage = editImage(img, overlayImage);
            const blob = await new Promise(resolve => editedImage.toBlob(resolve, 'image/jpeg'));
            zip.file(file.name, blob);
        }

        // Generate the ZIP file and provide download link
        zip.generateAsync({ type: 'blob' }).then(content => {
            const downloadLink = document.getElementById('download-link');
            downloadLink.href = URL.createObjectURL(content);
            downloadLink.download = 'edited-images.zip';
            downloadLink.textContent = 'Download Edited Images';
            downloadLink.classList.remove('hidden');
        });
    }

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
            img.src = src;
        });
    }

    function editImage(image, overlay) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate new dimensions after cropping
        const newWidth = image.width - 85 - 85; // 85px crop from left and right
        const newHeight = image.height - 285 - 385; // 285px crop from top, 385px from bottom

        // Set canvas size to match the new cropped size
        canvas.width = newWidth;
        canvas.height = newHeight;

        // Draw the original image cropped
        ctx.drawImage(image, 85, 285, newWidth, newHeight, 0, 0, newWidth, newHeight);

        // Draw the overlay on top of the cropped image at adjusted position
        ctx.drawImage(overlay, 225 - 85, 616 - 285); // Adjusted position after cropping

        return canvas;
    }
</script>
</body>
</html>
